### 最长公共子序列与最长公共子串

子串应该比较好理解，至于什么是子序列，这里给出一个例子：有两个母串

- cnblogs
- belong

比如序列bo, bg, lg在母串cnblogs与belong中都出现过并且出现顺序与母串保持一致，我们将其称为公共子序列。最长公共子序列（Longest Common Subsequence, LCS），顾名思义，是指在所有的子序列中最长的那一个。子串是要求更严格的一种子序列，要求在母串中连续地出现。在上述例子的中，最长公共子序列为blog（cn**blog**s, **b**e**lo**n**g**），最长公共子串为lo（cnb**lo**gs, be**lo**ng）。

对于母串X=<x1,x2,⋯,xm>X=<x1,x2,⋯,xm>, Y=<y1,y2,⋯,yn>Y=<y1,y2,⋯,yn>，求LCS与最长公共子串。

**暴力解法：**

假设 m<nm<n， 对于母串XX，我们可以暴力找出2m2m个子序列，然后依次在母串YY中匹配，算法的时间复杂度会达到指数级O(n∗2m)O(n∗2m)。显然，暴力求解不太适用于此类问题。

**动态规划：**

假设Z=<z1,z2,⋯,zk>Z=<z1,z2,⋯,zk> 是XX 与YY 的LCS， 我们观察到

- 如果xm=ynxm=yn ，则zk=xm=ynzk=xm=yn ，有Zk−1Zk−1 是Xm−1Xm−1 与Yn−1Yn−1 的LCS；
- 如果xm≠ynxm≠yn ，则ZkZk 是XmXm 与Yn−1Yn−1 的LCS，或者是Xm−1Xm−1 与YnYn 的LCS。

因此，求解LCS的问题则变成递归求解的两个子问题。但是，上述的递归求解的办法中，重复的子问题多，效率低下。改进的办法——**用空间换时间**，用数组保存中间状态，方便后面的计算。这就是动态规划（DP)的核心思想了